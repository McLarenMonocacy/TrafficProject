import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import java.util.LinkedList;
import java.time.Duration;
import static org.junit.jupiter.api.Assertions.*;

class ArrivalProcessTest {

    private TransitMap testMap;

    @BeforeEach
    void setUp() {
        SimulationEngine.finishedCommuters = new LinkedList<>();

        testMap = new TransitMap();
        TransitNode node1 = new TransitNode("NodeA");
        TransitNode node2 = new TransitNode("NodeB");
        TransitNode node3 = new TransitNode("NodeC");

        testMap.addNode(node1);
        testMap.addNode(node2);
        testMap.addNode(node3);

        testMap.addConnection(node1, node2, 1.0f, 1.0f);
        testMap.addConnection(node2, node3, 1.0f, 1.0f);
        testMap.addConnection(node3, node1, 1.0f, 1.0f);

        testMap.genPathTables();
    }

    @Test
    void testConstructorInitialState() {
        ArrivalProcess ap = new ArrivalProcess(0.5, testMap);
        assertEquals(0.0, ap.getNextArrivalTime(), 0.001, "First arrival should always be at time 0.0");
    }

    @Test
    void testTimeadvancesMonotonically() {
        ArrivalProcess ap = new ArrivalProcess(1.0, testMap);
        double previousTime = ap.getNextArrivalTime();

        for(int i = 0; i < 50; i++) {
            ap.generateNextCommuter();
            double currentTime = ap.getNextArrivalTime();
            assertTrue(currentTime > previousTime, "Time must move forward after every generation");
            previousTime = currentTime;
        }
    }

    @Test
    void testCommuterActuallyAddedToSystem() {
        ArrivalProcess ap = new ArrivalProcess(1.0, testMap);
        ap.generateNextCommuter();
        assertTrue(ap.getNextArrivalTime() > 0, "Arrival time should advance, indicating process ran");
    }

    @Test
    void testAdvanceArrivalWithoutGeneration() {
        ArrivalProcess ap = new ArrivalProcess(1.0, testMap);
        int initialCount = countTotalVehiclesInSystem(testMap);
        double initialTime = ap.getNextArrivalTime();

        ap.advanceArrival();

        int newCount = countTotalVehiclesInSystem(testMap);
        double newTime = ap.getNextArrivalTime();

        assertTrue(newTime > initialTime, "Time should advance");
        assertEquals(initialCount, newCount, "No commuters should be generated by advanceArrival()");
    }

    @Test
    void testArrivalRateStatistics() {
        ArrivalProcess fastProcess = new ArrivalProcess(100.0, testMap);
        ArrivalProcess slowProcess = new ArrivalProcess(0.01, testMap);

        double fastAverage = calculateAverageInterval(fastProcess, 1000);
        double slowAverage = calculateAverageInterval(slowProcess, 1000);

        assertTrue(fastAverage < slowAverage, "Fast process (high lambda) should have shorter intervals");
        assertTrue(fastAverage < 1.0, "Fast average should be small");
        assertTrue(slowAverage > 10.0, "Slow average should be large");
    }

    @Test
    void testCommuterNeverBornAtDestination() {
        ArrivalProcess ap = new ArrivalProcess(1.0, testMap);

        for(int i = 0; i < 20; i++) {
            ap.generateNextCommuter();
        }

        assertEquals(0, SimulationEngine.finishedCommuters.size(),
                "Commuters should not spawn at their destination");
    }

    @Test
    @Disabled("ArrivalProcess hangs indefinitely if map has only 1 node.")
    void testSingleNodeMap_DetectsInfiniteLoop() {

        TransitMap smallMap = new TransitMap();
        smallMap.addNode(new TransitNode("LonelyNode"));
        ArrivalProcess ap = new ArrivalProcess(1.0, smallMap);

        assertTimeoutPreemptively(Duration.ofMillis(100), () -> {
            try {
                ap.generateNextCommuter();
            } catch (Exception e) {
            }
        }, "ArrivalProcess hangs indefinitely if map has only 1 node");
    }

    @Test
    void testEmptyMap_HandleGracefully() {
        TransitMap emptyMap = new TransitMap();
        ArrivalProcess ap = new ArrivalProcess(1.0, emptyMap);
        assertThrows(Exception.class, () -> {
            ap.generateNextCommuter();
        }, "Should throw exception rather than hang on empty map");
    }

    private int countTotalVehiclesInSystem(TransitMap map) {
        int total = 0;
        for (TransitNode node : map.getNodes()) {
            for (TransitConnection conn : node.getConnections()) {
                total += conn.getNumbOfWaitingVehicles();
            }
        }
        return total;
    }

    private double calculateAverageInterval(ArrivalProcess ap, int iterations) {
        double startTime = ap.getNextArrivalTime();
        for (int i = 0; i < iterations; i++) {
            ap.advanceArrival();
        }
        double endTime = ap.getNextArrivalTime();
        return (endTime - startTime) / iterations;
    }
}